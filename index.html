<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess vs Bot</title>

  <!-- chess.js from cdnjs (stable UMD build) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

  <style>
    :root {
      --light: #f0d9b5;
      --dark:  #b58863;
      --highlight: rgba(253,230,138,0.95);
      --accent: #0ea5e9;
      --board-size: 480px;
    }
    body {
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: #f3f4f6;
      padding: 24px;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      box-sizing: border-box;
    }
    .container {
      width: min(1100px, 96%);
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 6px 30px rgba(0,0,0,0.08);
      padding: 18px;
      box-sizing: border-box;
    }
    header { display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; }
    h1 { font-size:20px; margin:0; }
    .controls button { margin-left:8px; padding:8px 12px; border-radius:8px; border:0; cursor:pointer; }
    .btn-primary { background:#2563eb; color:white; }
    .btn-secondary { background:#e5e7eb; color:#111827; }

    .main { display:flex; gap:18px; align-items:flex-start; }
    .board-wrap { width: var(--board-size); }
    .board {
      width: var(--board-size);
      height: var(--board-size);
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr);
      border: 2px solid rgba(0,0,0,0.06);
      box-sizing: border-box;
      user-select: none;
    }
    .square {
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      cursor:pointer;
      box-sizing:border-box;
    }
    .square.light { background: var(--light); }
    .square.dark { background: var(--dark); color: #111827; }
    .square.highlight { background: var(--highlight) !important; }
    .square.selected { outline: 3px solid var(--accent); }

    .panel { flex:1; min-width: 260px; display:flex; flex-direction:column; gap:12px; }
    textarea { width:100%; height:120px; resize:vertical; padding:8px; box-sizing:border-box; border-radius:8px; border:1px solid #e5e7eb; }
    label { font-size:13px; color:#111827; display:block; margin-bottom:6px; }
    .small { font-size:13px; color:#6b7280; }

    .footer { margin-top:12px; font-size:12px; color:#6b7280; }

    .status { font-weight:600; }
    .legend { font-size:13px; color:#374151; }

    /* responsive tweak */
    @media (max-width: 880px) {
      .main { flex-direction:column; align-items:center; }
      .board-wrap { width: min(90vw, 480px); }
      .board { width: min(90vw, 480px); height: min(90vw,480px); }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Chess vs Bot</h1>
      <div class="controls">
        <button class="btn-primary" id="newBtn">New Game</button>
        <button class="btn-secondary" id="undoBtn">Undo</button>
        <button class="btn-secondary" id="flipBtn">Flip</button>
      </div>
    </header>

    <div class="main">
      <div class="board-wrap">
        <div id="board" class="board" aria-label="Chess board"></div>
        <div class="small" id="orientationLabel" style="margin-top:8px;">Orientation: White at bottom</div>
      </div>

      <div class="panel">
        <div>
          <div class="status" id="status">White to move</div>
          <div class="small" id="checkInfo"></div>
        </div>

        <div>
          <label for="difficulty">Difficulty (search depth): <span id="diffVal">2</span></label>
          <input id="difficulty" type="range" min="1" max="3" value="2" />
          <div class="small">Higher depth = stronger bot but slower.</div>
        </div>

        <div>
          <label>Moves (PGN)</label>
          <textarea id="pgn" readonly></textarea>
        </div>

        <div>
          <div class="legend">Legend</div>
          <div class="small">Click a white piece to view legal moves. Click a destination to move. Promotion auto-queens. Bot plays Black.</div>
        </div>

        <div class="small">Thinking: <span id="thinking">No</span></div>
      </div>
    </div>

    <div class="footer">
      Built with chess.js (rules). Want drag-and-drop, engine integration (Stockfish WASM), or multiplayer? Ask and I'll add it.
    </div>
  </div>

  <script>
    // Ensure chess.js loaded
    if (typeof Chess === 'undefined') {
      alert('chess.js failed to load. Check CDN link.');
    }

    // Map chess.js board squares to Unicode pieces
    const UNICODE = {
      'p': { w: '♙', b: '♟' },
      'n': { w: '♘', b: '♞' },
      'b': { w: '♗', b: '♝' },
      'r': { w: '♖', b: '♜' },
      'q': { w: '♕', b: '♛' },
      'k': { w: '♔', b: '♚' }
    };

    // Material values for evaluation
    const PIECE_VALUE = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

    // State
    let game = new Chess();
    let selected = null;           // square string e.g. 'e2'
    let legalMoves = [];           // moves verbose objects for selected
    let orientationWhite = true;   // whether white at bottom
    let thinking = false;

    // DOM refs
    const boardEl = document.getElementById('board');
    const statusEl = document.getElementById('status');
    const diffEl = document.getElementById('difficulty');
    const diffValEl = document.getElementById('diffVal');
    const pgnEl = document.getElementById('pgn');
    const thinkingEl = document.getElementById('thinking');
    const newBtn = document.getElementById('newBtn');
    const undoBtn = document.getElementById('undoBtn');
    const flipBtn = document.getElementById('flipBtn');
    const orientationLabel = document.getElementById('orientationLabel');
    const checkInfo = document.getElementById('checkInfo');

    // Create board squares once
    const squares = []; // array of square names in grid order (top-left -> bottom-right)
    (function initSquares(){
      // We'll maintain squares array with board rendering order -> we will re-map if flipped
      const files = ['a','b','c','d','e','f','g','h'];
      for (let r = 8; r >= 1; r--) {
        for (let f = 0; f < 8; f++) {
          squares.push(files[f] + r);
        }
      }
    })();

    // Build board DOM
    function buildBoard() {
      boardEl.innerHTML = '';
      // choose render order depending on orientation
      const order = orientationWhite ? [...squares] : [...squares].reverse();
      order.forEach((sq, idx) => {
        const div = document.createElement('div');
        div.className = 'square';
        // determine light / dark based on algebraic coordinates
        const file = sq.charCodeAt(0) - 97;
        const rank = parseInt(sq[1], 10) - 1;
        const isLight = (file + rank) % 2 === 0;
        div.classList.add(isLight ? 'light' : 'dark');
        div.setAttribute('data-square', sq);
        div.addEventListener('click', onSquareClick);
        boardEl.appendChild(div);
      });
    }

    // Render pieces and highlights
    function render() {
      // update squares
      const order = orientationWhite ? [...squares] : [...squares].reverse();
      const board = game.board(); // rows 0..7 rank8..rank1
      // build a map square -> piece
      const map = {};
      for (let r = 7; r >= 0; r--) {
        for (let f = 0; f < 8; f++) {
          const sq = String.fromCharCode(97 + f) + (r + 1);
          const piece = board[r][f];
          map[sq] = piece ? piece : null;
        }
      }

      // update each div
      const nodes = boardEl.querySelectorAll('.square');
      nodes.forEach(node => {
        const sq = node.getAttribute('data-square');
        // piece display
        const piece = map[sq];
        node.textContent = piece ? UNICODE[piece.type][piece.color] : '';
        node.classList.remove('highlight','selected');
        // highlight legal
        if (selected && selected === sq) node.classList.add('selected');
        if (legalMoves.some(m => m.to === sq)) node.classList.add('highlight');
      });

      // status and PGN
      updateStatus();
      pgnEl.value = game.pgn();
      thinkingEl.textContent = thinking ? 'Yes' : 'No';
      orientationLabel.textContent = orientationWhite ? 'Orientation: White at bottom' : 'Orientation: Black at bottom';
    }

    function updateStatus() {
      if (game.game_over()) {
        if (game.in_checkmate()) {
          statusEl.textContent = `Checkmate — ${game.turn() === 'w' ? 'Black' : 'White'} wins`;
        } else if (game.in_draw()) {
          statusEl.textContent = 'Draw';
        } else {
          statusEl.textContent = 'Game over';
        }
        checkInfo.textContent = '';
        return;
      }
      const turn = game.turn() === 'w' ? 'White' : 'Black';
      const inCheck = game.in_check() ? ' — check' : '';
      statusEl.textContent = `${turn} to move${inCheck}`;
      checkInfo.textContent = game.in_check() ? 'King is in check' : '';
    }

    function onSquareClick(e) {
      if (thinking) return;
      const sq = e.currentTarget.getAttribute('data-square');
      // If something selected
      if (selected) {
        // if clicked same square -> unselect
        if (selected === sq) {
          selected = null;
          legalMoves = [];
          render();
          return;
        }
        // if clicked a legal destination -> move
        const isLegal = legalMoves.some(m => m.to === sq);
        if (isLegal) {
          const g = new Chess(game.fen());
          g.move({ from: selected, to: sq, promotion: 'q' });
          game = g;
          selected = null;
          legalMoves = [];
          render();
          // after player's move, trigger bot if black to move
          if (!game.game_over() && game.turn() === 'b') runBotMove();
          return;
        }
      }

      // if no selection: try to select if piece present and is player's color (white)
      const piece = game.get(sq);
      if (piece && piece.color === 'w' && game.turn() === 'w') {
        const moves = game.moves({ square: sq, verbose: true });
        selected = sq;
        legalMoves = moves;
        render();
      } else {
        // clicked empty or enemy piece: clear selection
        selected = null;
        legalMoves = [];
        render();
      }
    }

    // Evaluation function (material only)
    function evaluateBoard(g) {
      const board = g.board();
      let score = 0;
      for (let r = 0; r < 8; r++) {
        for (let f = 0; f < 8; f++) {
          const sq = board[r][f];
          if (sq) {
            const val = PIECE_VALUE[sq.type] || 0;
            score += (sq.color === 'w') ? val : -val;
          }
        }
      }
      return score;
    }

    // Minimax + alpha-beta (returns [score, bestMoveVerbose])
    function minimax(g, depth, alpha, beta, isMaximizing) {
      if (depth === 0 || g.game_over()) {
        return [evaluateBoard(g), null];
      }
      const moves = g.moves({ verbose: true });
      if (isMaximizing) {
        let maxEval = -Infinity;
        let bestMove = null;
        for (let i = 0; i < moves.length; i++) {
          const m = moves[i];
          g.move(m.san);
          const [evalScore] = minimax(g, depth - 1, alpha, beta, false);
          g.undo();
          if (evalScore > maxEval) {
            maxEval = evalScore;
            bestMove = m;
          }
          alpha = Math.max(alpha, evalScore);
          if (beta <= alpha) break;
        }
        return [maxEval, bestMove];
      } else {
        let minEval = Infinity;
        let bestMove = null;
        for (let i = 0; i < moves.length; i++) {
          const m = moves[i];
          g.move(m.san);
          const [evalScore] = minimax(g, depth - 1, alpha, beta, true);
          g.undo();
          if (evalScore < minEval) {
            minEval = evalScore;
            bestMove = m;
          }
          beta = Math.min(beta, evalScore);
          if (beta <= alpha) break;
        }
        return [minEval, bestMove];
      }
    }

    // Trigger bot move (Black)
    function runBotMove() {
      if (game.game_over()) return;
      if (game.turn() !== 'b') return;
      thinking = true;
      render();
      // Do search in a small timeout so UI updates
      setTimeout(() => {
        const depth = Number(diffEl.value) || 2;
        const g = new Chess(game.fen());
        // We will maximize for black (since evaluation is white minus black, we invert)
        // To keep same logic as the React version (maximize for side to move), call minimax with true if black?
        // In our evaluateBoard, positive = advantage for White. When black to move, we want to pick moves minimizing evaluation.
        // Simpler: call minimax with isMaximizing = false because we want minimize (black wants lower score).
        // But in the React version we used maximizing player true for black. To keep it consistent, do this:
        // We'll treat maximizing as black's perspective by negating evaluation inside minimax — simpler approach: call as usual but interpret bestMove.
        // To avoid confusion, we'll run a shallow wrapper that chooses best move for black by trying all moves and picking the one with lowest resulting eval from minimax.
        const moves = g.moves({ verbose: true });
        let best = null;
        let bestScore = Infinity;
        for (let i = 0; i < moves.length; i++) {
          const m = moves[i];
          g.move(m.san);
          const [score] = minimax(g, depth - 1, -Infinity, Infinity, true); // now white to move (maximize)
          g.undo();
          // since score is eval from White perspective, lower score is better for Black
          if (score < bestScore) {
            bestScore = score;
            best = m;
          }
        }

        if (best) {
          const newG = new Chess(game.fen());
          newG.move(best.san);
          game = newG;
        }
        thinking = false;
        render();
      }, 40);
    }

    // Buttons
    newBtn.addEventListener('click', () => {
      game = new Chess();
      selected = null;
      legalMoves = [];
      thinking = false;
      render();
    });

    undoBtn.addEventListener('click', () => {
      if (thinking) return;
      // undo last two plies (black then white). If only one ply exists, just undo one.
      game.undo();
      // try undo second ply
      if (game.history().length % 2 === 1) {
        // if odd remaining moves, undo one more to remove player's move as well
        game.undo();
      }
      selected = null;
      legalMoves = [];
      thinking = false;
      render();
    });

    flipBtn.addEventListener('click', () => {
      orientationWhite = !orientationWhite;
      buildBoard();
      render();
    });

    // Difficulty slider
    diffEl.addEventListener('input', () => {
      diffValEl.textContent = diffEl.value;
    });

    // initial build + render
    buildBoard();
    render();

    // If it's black's turn on load (rare), run bot
    if (game.turn() === 'b') runBotMove();

    // Keyboard support: press 'r' to reset
    document.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        game = new Chess();
        selected = null;
        legalMoves = [];
        thinking = false;
        render();
      }
    });

    // Small note: the bot is simple (material-only evaluation). For a much stronger bot consider integrating Stockfish WASM.
  </script>
</body>
</html>
